// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package gen

import (
	"context"

	"github.com/google/uuid"
)

const countResourceCacheBefore = `-- name: CountResourceCacheBefore :one
SELECT count(*) FROM resource_cache WHERE namespace = $1::TEXT AND version_index < $2::BIGINT
`

type CountResourceCacheBeforeParams struct {
	Namespace          string
	BeforeVersionIndex int64
}

func (q *Queries) CountResourceCacheBefore(ctx context.Context, arg CountResourceCacheBeforeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countResourceCacheBefore, arg.Namespace, arg.BeforeVersionIndex)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const dropResourceCache = `-- name: DropResourceCache :exec
DELETE FROM resource_cache WHERE namespace = $1::TEXT AND id = $2::UUID
`

type DropResourceCacheParams struct {
	Namespace string
	ID        uuid.UUID
}

func (q *Queries) DropResourceCache(ctx context.Context, arg DropResourceCacheParams) error {
	_, err := q.db.ExecContext(ctx, dropResourceCache, arg.Namespace, arg.ID)
	return err
}

const dropResourceCacheBefore = `-- name: DropResourceCacheBefore :exec
DELETE FROM resource_cache WHERE namespace = $1::TEXT AND version_index < $2::BIGINT
`

type DropResourceCacheBeforeParams struct {
	Namespace          string
	BeforeVersionIndex int64
}

func (q *Queries) DropResourceCacheBefore(ctx context.Context, arg DropResourceCacheBeforeParams) error {
	_, err := q.db.ExecContext(ctx, dropResourceCacheBefore, arg.Namespace, arg.BeforeVersionIndex)
	return err
}

const getResourceCacheSummary = `-- name: GetResourceCacheSummary :one
SELECT
    version_index,
    sha256_hash
FROM resource_cache AS rc WHERE rc.namespace = $1::TEXT AND rc.id = $2::UUID
`

type GetResourceCacheSummaryParams struct {
	Namespace string
	ID        uuid.UUID
}

type GetResourceCacheSummaryRow struct {
	VersionIndex int64
	Sha256Hash   string
}

func (q *Queries) GetResourceCacheSummary(ctx context.Context, arg GetResourceCacheSummaryParams) (GetResourceCacheSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getResourceCacheSummary, arg.Namespace, arg.ID)
	var i GetResourceCacheSummaryRow
	err := row.Scan(&i.VersionIndex, &i.Sha256Hash)
	return i, err
}

const insertActiveResourceEvent = `-- name: InsertActiveResourceEvent :exec
INSERT INTO resource_events (
    namespace,
    id,
    version_index,
    status,
    name,
    spec_type_url,
    spec_value,
    sha256_hash
) SELECT
    rc.namespace,
    rc.id,
    rc.version_index,
    'ACTIVE'::text,
    rc.name,
    rc.spec_type_url,
    rc.spec_value,
    rc.sha256_hash
FROM resource_cache AS rc
WHERE rc.namespace = $1::TEXT AND
rc.id = $2::UUID
`

type InsertActiveResourceEventParams struct {
	Namespace string
	ID        uuid.UUID
}

func (q *Queries) InsertActiveResourceEvent(ctx context.Context, arg InsertActiveResourceEventParams) error {
	_, err := q.db.ExecContext(ctx, insertActiveResourceEvent, arg.Namespace, arg.ID)
	return err
}

const insertDroppedResourceBeforeEvent = `-- name: InsertDroppedResourceBeforeEvent :exec
INSERT INTO resource_events (
    namespace,
    id,
    version_index,
    status,
    name,
    spec_type_url,
    spec_value,
    sha256_hash
) SELECT
    rc.namespace,
    rc.id,
    $1::BIGINT,
    'DROPPED'::text,
    rc.name,
    rc.spec_type_url,
    rc.spec_value,
    rc.sha256_hash
FROM resource_cache AS rc
WHERE rc.namespace = $2::TEXT AND
rc.version_index < $3::BIGINT
`

type InsertDroppedResourceBeforeEventParams struct {
	VersionIndex       int64
	Namespace          string
	BeforeVersionIndex int64
}

func (q *Queries) InsertDroppedResourceBeforeEvent(ctx context.Context, arg InsertDroppedResourceBeforeEventParams) error {
	_, err := q.db.ExecContext(ctx, insertDroppedResourceBeforeEvent, arg.VersionIndex, arg.Namespace, arg.BeforeVersionIndex)
	return err
}

const insertDroppedResourceEvent = `-- name: InsertDroppedResourceEvent :exec
INSERT INTO resource_events (
    namespace,
    id,
    version_index,
    status,
    name,
    spec_type_url,
    spec_value,
    sha256_hash
) SELECT
    rc.namespace,
    rc.id,
    $1::BIGINT,
    'DROPPED'::TEXT,
    rc.name,
    rc.spec_type_url,
    rc.spec_value,
    rc.sha256_hash
FROM resource_cache AS rc
WHERE rc.namespace = $2::TEXT AND
rc.id = $3::UUID
`

type InsertDroppedResourceEventParams struct {
	VersionIndex int64
	Namespace    string
	ID           uuid.UUID
}

func (q *Queries) InsertDroppedResourceEvent(ctx context.Context, arg InsertDroppedResourceEventParams) error {
	_, err := q.db.ExecContext(ctx, insertDroppedResourceEvent, arg.VersionIndex, arg.Namespace, arg.ID)
	return err
}

const listResourcesCachedFromNamespace = `-- name: ListResourcesCachedFromNamespace :many
SELECT
    id,
    version_index,
    name,
    spec_type_url,
    spec_value,
    sha256_hash
FROM
    resource_cache AS re
WHERE
    re.namespace = $1::TEXT
ORDER BY
    re.namespace ASC,
    re.version_index ASC
LIMIT $3 OFFSET $2
`

type ListResourcesCachedFromNamespaceParams struct {
	Namespace  string
	RowsOffset int32
	MaxRows    int32
}

type ListResourcesCachedFromNamespaceRow struct {
	ID           uuid.UUID
	VersionIndex int64
	Name         string
	SpecTypeUrl  string
	SpecValue    []byte
	Sha256Hash   string
}

func (q *Queries) ListResourcesCachedFromNamespace(ctx context.Context, arg ListResourcesCachedFromNamespaceParams) ([]ListResourcesCachedFromNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourcesCachedFromNamespace, arg.Namespace, arg.RowsOffset, arg.MaxRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesCachedFromNamespaceRow
	for rows.Next() {
		var i ListResourcesCachedFromNamespaceRow
		if err := rows.Scan(
			&i.ID,
			&i.VersionIndex,
			&i.Name,
			&i.SpecTypeUrl,
			&i.SpecValue,
			&i.Sha256Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesEventsFromNamespace = `-- name: ListResourcesEventsFromNamespace :many
SELECT
    id,
    version_index,
    status,
    name,
    spec_type_url,
    spec_value,
    sha256_hash
FROM
    resource_events AS re
WHERE
    (re.namespace, re.version_index, re.id) > ($1::TEXT, $2::BIGINT, $3::UUID)
ORDER BY
    re.namespace ASC,
    re.version_index ASC,
    re.id ASC
LIMIT $4 OFFSET 0
`

type ListResourcesEventsFromNamespaceParams struct {
	Namespace        string
	FromVersionIndex int64
	FromID           uuid.UUID
	MaxRows          int32
}

type ListResourcesEventsFromNamespaceRow struct {
	ID           uuid.UUID
	VersionIndex int64
	Status       string
	Name         string
	SpecTypeUrl  string
	SpecValue    []byte
	Sha256Hash   string
}

func (q *Queries) ListResourcesEventsFromNamespace(ctx context.Context, arg ListResourcesEventsFromNamespaceParams) ([]ListResourcesEventsFromNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourcesEventsFromNamespace,
		arg.Namespace,
		arg.FromVersionIndex,
		arg.FromID,
		arg.MaxRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesEventsFromNamespaceRow
	for rows.Next() {
		var i ListResourcesEventsFromNamespaceRow
		if err := rows.Scan(
			&i.ID,
			&i.VersionIndex,
			&i.Status,
			&i.Name,
			&i.SpecTypeUrl,
			&i.SpecValue,
			&i.Sha256Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const maxVersionIndexForNamespace = `-- name: MaxVersionIndexForNamespace :one
SELECT
    id,
    version_index
FROM
    resource_events AS re
WHERE
    re.namespace = $1::TEXT
ORDER BY
    re.namespace DESC,
    re.version_index DESC,
    re.id DESC
LIMIT 1
`

type MaxVersionIndexForNamespaceRow struct {
	ID           uuid.UUID
	VersionIndex int64
}

func (q *Queries) MaxVersionIndexForNamespace(ctx context.Context, namespace string) (MaxVersionIndexForNamespaceRow, error) {
	row := q.db.QueryRowContext(ctx, maxVersionIndexForNamespace, namespace)
	var i MaxVersionIndexForNamespaceRow
	err := row.Scan(&i.ID, &i.VersionIndex)
	return i, err
}

const upsertResourceCache = `-- name: UpsertResourceCache :exec
INSERT INTO resource_cache (
    namespace,
    id,
    version_index,
    name,
    spec_type_url,
    spec_value,
    sha256_hash
) VALUES (
    $1::TEXT,
    $2::UUID,
    $3::BIGINT,
    $4::TEXT,
    $5::TEXT,
    $6::BYTEA,
    $7::TEXT
) ON CONFLICT (namespace, id)
DO UPDATE SET 
    version_index = EXCLUDED.version_index,
    name = EXCLUDED.name,
    spec_type_url = EXCLUDED.spec_type_url,
    spec_value = EXCLUDED.spec_value,
    sha256_hash = EXCLUDED.sha256_hash
`

type UpsertResourceCacheParams struct {
	Namespace    string
	ID           uuid.UUID
	VersionIndex int64
	Name         string
	SpecTypeUrl  string
	SpecValue    []byte
	Sha256Hash   string
}

func (q *Queries) UpsertResourceCache(ctx context.Context, arg UpsertResourceCacheParams) error {
	_, err := q.db.ExecContext(ctx, upsertResourceCache,
		arg.Namespace,
		arg.ID,
		arg.VersionIndex,
		arg.Name,
		arg.SpecTypeUrl,
		arg.SpecValue,
		arg.Sha256Hash,
	)
	return err
}
